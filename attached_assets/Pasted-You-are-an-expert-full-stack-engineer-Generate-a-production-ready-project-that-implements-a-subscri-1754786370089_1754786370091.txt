You are an expert full-stack engineer. Generate a production-ready project that implements a subscription PDF reader with offline access, device-bound DRM-style licenses, and an account-wide loan cap. Use:

Backend: Node.js + Express, PostgreSQL (node-pg), JWT for auth (email/password placeholder OK), Ed25519 for signing licenses.

Frontend: React + TypeScript + Vite, PWA (Service Worker + manifest), IndexedDB for storage, WebCrypto API for key management & decryption, Workbox (or vanilla SW) for background sync.

Reader: In-browser PDF rendering (PDF.js), decrypt-on-the-fly per chunk, watermark overlay.

Core Features
Borrowing with account-wide cap

Users can borrow up to 20 active loans at once across all devices.

API enforces cap; borrowing the 21st requires returning one.

Device registration & binding

On first login per device, generate a device keypair (WebCrypto).

Send public key to server; server stores deviceId, public_key.

Licenses are bound to (userId, deviceId, loanId) and are not transferable.

Encrypted delivery

PDFs are stored on server encrypted (AES-GCM).

Content is served as encrypted chunks (e.g., 1MB each).

License includes a wrapped asset key (wrapped with device public key).

Signed, expiring licenses

License JSON includes: licenseId, loanId, userId, deviceId, bookId, policy.offlineExpiresAt (~30 days), watermark{name,email,loanId}, key{alg:'AES-GCM', keyWrapped}, asset{sha256, chunkCount, chunkSize}.

Entire license is Ed25519-signed by the server.

Client verifies signature before use.

Renewal flow: Background sync refreshes offlineExpiresAt before expiry; if offline beyond expiry, reader blocks until online.

Revocation & auto-return

Returning a loan or revoking server-side invalidates licenses on next sync.

Client deletes keys/chunks for revoked licenses.

Offline reading

Download manifest + encrypted chunks into IndexedDB.

Decrypt per chunk in memory when rendering.

Watermark drawn over each page (visible), include user/email/loanId.

Admin controls

Adjust loan cap, set offline window days, revoke licenses, force device invalidation, view last renewal times.

Project Structure
bash
Copy
Edit
/server
  /src
    app.ts
    env.ts
    db.ts
    crypto.ts (Ed25519 sign/verify; AES helpers)
    middleware/auth.ts
    routes/auth.ts
    routes/devices.ts
    routes/loans.ts
    routes/licenses.ts
    routes/books.ts
    services/licenseService.ts
    services/loanService.ts
    services/bookEncryptor.ts
    sql/schema.sql
  package.json

/web
  /src
    main.tsx
    App.tsx
    api/client.ts
    auth/AuthContext.tsx
    devices/useDeviceRegistration.ts
    reader/PdfReader.tsx
    reader/crypto.ts (unwrap/decrypt)
    reader/idb.ts
    sw.ts (service worker with background sync)
    pages/Login.tsx
    pages/Library.tsx
    pages/Reader.tsx
    components/WatermarkedCanvas.tsx
    types.ts
  public/manifest.webmanifest
  vite.config.ts
  package.json
Database Schema (PostgreSQL)
Implement via /server/src/sql/schema.sql:

sql
Copy
Edit
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE devices (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id),
  name TEXT,
  public_key TEXT NOT NULL,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE books (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  title TEXT NOT NULL,
  author TEXT,
  storage_path TEXT NOT NULL,   -- encrypted file/chunks location
  sha256 TEXT NOT NULL,
  size BIGINT NOT NULL,
  chunk_size INT NOT NULL DEFAULT 1048576,
  chunk_count INT NOT NULL
);

CREATE TABLE loans (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id),
  book_id UUID REFERENCES books(id),
  status TEXT CHECK (status IN ('active','returned','revoked')) DEFAULT 'active',
  started_at TIMESTAMPTZ DEFAULT now(),
  returned_at TIMESTAMPTZ
);

CREATE TABLE licenses (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  loan_id UUID REFERENCES loans(id),
  device_id UUID REFERENCES devices(id),
  offline_expires_at TIMESTAMPTZ NOT NULL,
  key_wrapped BYTEA NOT NULL,
  policy JSONB NOT NULL,
  signature BYTEA NOT NULL,
  revoked BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT now()
);
Environment Variables
ini
Copy
Edit
# Server
PORT=5000
DATABASE_URL=postgres://user:pass@host:5432/db
JWT_SECRET=change_me_min_32_chars
LICENSE_SIGN_PRIV_KEY_BASE64=...   # Ed25519 private key
LICENSE_SIGN_PUB_KEY_BASE64=...    # Ed25519 public key
OFFLINE_WINDOW_DAYS=30
LOAN_CAP=20
ASSET_STORAGE_DIR=/data/assets     # encrypted chunks root

# Web
VITE_API_BASE=http://localhost:5000
Backend Requirements (Express)
JWT auth: /auth/register, /auth/login.

Devices

POST /devices/register {name, publicKey} → {deviceId}

GET /devices/me → list devices for current user; allow deactivation.

Loans

POST /loans {bookId} → create loan if active_count < LOAN_CAP, else 409.

POST /loans/:loanId/return → mark returned; revoke linked licenses.

GET /loans → list user loans with book metadata.

Licenses

POST /licenses {loanId, deviceId} → issue license with offline_expires_at=now()+OFFLINE_WINDOW_DAYS.

POST /licenses/renew {licenseId} → extend window; return updated signed license (new offlineExpiresAt).

GET /licenses/updates?deviceId=... → batch revocations/updated policies.

Books

GET /books → list (id, title, author).

GET /books/:bookId/manifest → {sha256, chunkSize, chunkCount, chunkIds[]}.

GET /books/:bookId/chunks/:chunkId → returns encrypted bytes (auth + entitlement check).

Server crypto helpers
Ed25519: sign/verify license payloads.

AES-GCM: server-side encrypt PDFs to chunks (CLI or script) with random K_asset per book; store chunk IVs alongside.

On license issue: wrap K_asset with device public key (RSA-OAEP or X25519/ECDH + AES-KW). Store key_wrapped in DB; embed base64 in license JSON.

Include serverTime in license to mitigate clock tamper. Client compares device time skew.

Enforcement
Check entitlement on every chunk request: user owns active loan AND license not revoked.

On renewal, update offline_expires_at and return a freshly signed license object.

On return/revoke, mark licenses revoked=true. /licenses/updates should deliver deltas since ?since=timestamp.

Frontend Requirements (React + PWA)
Auth pages for sign-in/up.

Device registration hook: on first auth in a browser, create WebCrypto keypair, POST public key, store deviceId in IndexedDB.

Library page: list books; Borrow/Return buttons; display active loans count / 20.

Reader

On “Download for offline”: fetch manifest → stream encrypted chunks → store in IndexedDB (chunks store keyed by bookId|chunkId).

Request license for this loanId, deviceId; verify Ed25519 signature.

Schedule renewal alarm at offlineExpiresAt - 72h; also try renew daily via background sync.

When opening: if now > offlineExpiresAt, block and prompt to reconnect.

Decrypt per chunk using unwrapped K_asset (WebCrypto), render with PDF.js to canvas.

Watermark overlay: draw user/email/loanId faintly on each page.

IndexedDB stores

licenses (licenseId → license JSON)

chunks (${bookId}|${chunkId} → encrypted bytes, iv)

devices (deviceId, privateKey handle if needed)

Service Worker (sw.ts)

Intercept chunk requests; serve from IndexedDB when offline.

Background sync task:

Renew soon-expiring licenses.

Poll /licenses/updates for revocations; delete revoked keys/chunks.

Security & Abuse Mitigation
Never store plaintext PDFs client-side. Decrypt in memory only.

Watermark every rendered page (visible).

Compare license.serverTime to device clock; if skew > 10 minutes, force online check.

Limit devices per user (e.g., 5) server-configurable.

CSRF not needed for token auth; set HTTP-only cookie or Bearer token.

Developer Utilities
Provide a CLI/script to ingest a PDF:

Split into chunks, generate random K_asset, encrypt each chunk with AES-GCM (unique IV per chunk), compute SHA-256, write to ASSET_STORAGE_DIR, insert a books row with chunk_count & chunk_size.

Seed script to create a demo user and 3 sample books.

Tests & Acceptance
Unit tests for: loan cap enforcement, license signing/verification, renew flow, revocation flow.

Manual test script:

Register/login; register device.

Borrow 3 books; download offline; disconnect network → open successfully.

Advance system clock > 30 days (or set short window) → book should refuse until reconnect.

Reconnect and renew → access restored.

Borrow up to 20; attempt 21st → API returns 409.

Return one; borrow new → succeeds.

Revoke a loan in admin → next sync deletes local data; opening fails.

Deliverables
Full source for /server and /web apps with scripts:

server:dev, server:migrate, server:seed, server:start

web:dev, web:build, web:start

README with setup steps, env vars, and the ingest CLI usage.

Code comments where crypto is implemented (clear, concise).

Build the entire project now, with working code stubs where needed, so I can run npm install in both folders, migrate DB, seed data, start server and web, and test the flows above end-to-end.