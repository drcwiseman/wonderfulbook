You are my senior full-stack engineer. Implement a production-ready auth flow that collects name, email, and phone but does not use email verification or password reset (for now). Stack: Node.js (Express) + PostgreSQL + React (Vite).

Requirements
Registration form (React): fields = name (required), email (required), phone (required), password (required). Minimal friction, but validate on client and server.

Login form (React): email + password.

No email verification step and no password reset yet. Instead, include a “Contact Support to reset” link that hits a placeholder route.

Security:

Hash passwords with bcrypt (cost 10–12).

Use HttpOnly, Secure session cookies (with express-session or JWT in httpOnly cookie).

Add rate limiting (e.g., express-rate-limit) on /api/auth/register and /api/auth/login.

Add Cloudflare Turnstile or hCaptcha on both forms (free tier).

Validate inputs with express-validator.

Feature flags (env vars) so we can turn features on later without code changes:

ENABLE_EMAIL_VERIFICATION=false

ENABLE_PASSWORD_RESET=false

Admin-only manual reset route (temporary): protected by an admin token env var ADMIN_RESET_TOKEN.

POST /api/admin/users/:id/reset-password (body: newPassword) → bcrypt hash update.

Validate Authorization: Bearer <ADMIN_RESET_TOKEN>.

Database (PostgreSQL via SQL or migration)
Create tables with indexes and constraints:

users

id uuid PK default gen_random_uuid()

name text NOT NULL

email text UNIQUE NOT NULL

phone text NOT NULL (add index and optionally uniqueness)

password_hash text NOT NULL

is_active boolean NOT NULL default true

created_at timestamptz NOT NULL default now()

updated_at timestamptz NOT NULL default now()

Trigger/function to auto-update updated_at on change.

API endpoints (Express)
POST /api/auth/register

Validate: name min 2, email format, phone min 7, password min 6.

Turnstile/hCaptcha verify server-side.

Hash password, insert user, start session, return {ok:true, user} (exclude hash).

POST /api/auth/login

Validate email/password.

Rate limit (e.g., 5/min per IP).

Compare with bcrypt, start session, return {ok:true, user}.

POST /api/auth/logout → destroy session.

GET /api/auth/me → returns current user from session.

POST /api/support/request-reset (placeholder) → returns message “A team member will contact you to assist.” (no email required).

POST /api/admin/users/:id/reset-password (requires Authorization: Bearer <ADMIN_RESET_TOKEN>) → update password_hash.

Frontend (React + Vite)
Pages: /register, /login.

Forms with controlled inputs; show inline errors and captcha widget.

On success, redirect to /app (library/reader).

Add a small note under forms: “We’ll ask you to verify email later.”

Add link “Contact Support to reset password” → calls /api/support/request-reset.

Middleware & utils
requireAuth middleware to protect app routes.

rateLimiterRegister, rateLimiterLogin.

captchaVerify middleware (Turnstile/hCaptcha) checking server-side token.

Session config: secure, sameSite=lax/strict, rolling session on login.

Deliverables
SQL migration (or Prisma/Drizzle) for the users table + updated_at trigger.

server/ code: routes, validators, rate limits, captcha verify, session setup, admin reset route.

client/ components: RegisterForm.tsx, LoginForm.tsx, simple styles, captcha integration.

.env.example with:

DATABASE_URL=

SESSION_SECRET=

TURNSTILE_SECRET= (or HCAPTCHA_SECRET=)

ADMIN_RESET_TOKEN=

ENABLE_EMAIL_VERIFICATION=false

ENABLE_PASSWORD_RESET=false

README “How to run” (dev/prod) and curl examples for each endpoint.

Acceptance tests (manual or script)
Register succeeds, session cookie set, user row created.

Login succeeds with correct credentials; fails with wrong ones; rate limit works.

/api/auth/me returns the logged-in user.

Admin reset works with correct bearer token; fails otherwise.

Captcha required: requests without valid token are rejected.

Implement with clean, commented code and production-safe defaults.